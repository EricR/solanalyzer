package analyzers

import (
	"crypto/sha256"
	"fmt"
	"github.com/ericr/solanalyzer/scanner"
	"github.com/sirupsen/logrus"
	"io/ioutil"
	"net/http"
)

const (
	SeverityInfo int = iota
	SeverityLow
	SeverityMed
	SeverityHigh
)

// Analyzer is an interface for all analyzers
type Analyzer interface {
	GetName() string
	GetID() string
	Execute(*scanner.Source) ([]*Issue, error)
}

// Issue contains information generated by an analyzer to be reported.
type Issue struct {
	Severity   int
	Title      string
	MsgFormat  string
	Message    string
	sourcePath string
	tokens     *scanner.Tokens
	analyzer   Analyzer
}

// Group contains a group of analyzers that can be run.
type Group struct {
	Name          string
	Analyzers     []Analyzer
	AnalyzerNames []string
	Issues        []*Issue
}

func NewGroup(name string) *Group {
	return &Group{
		Name:      name,
		Analyzers: []Analyzer{},
	}
}

func (i *Issue) GetID() string {
	id := fmt.Sprintf("%s:%s:%s", i.GetAnalyzerID(), i.GetSource(), i.Message)

	return fmt.Sprintf("%x", sha256.Sum256([]byte(id)))
}

func (i *Issue) GetAnalyzerID() string {
	return i.analyzer.GetID()
}

func (i *Issue) GetSource() string {
	if i.tokens == nil || i.tokens.Start == nil {
		return fmt.Sprintf("%s:1:1", i.sourcePath)
	} else {
		return fmt.Sprintf("%s:%d:%d",
			i.sourcePath, i.tokens.Start.GetLine(), i.tokens.Start.GetColumn())
	}
}

// AddAnalyzer adds an analyzer to a group.
func (g *Group) AddAnalyzer(analyzer Analyzer) {
	g.Analyzers = append(g.Analyzers, analyzer)
	g.AnalyzerNames = append(g.AnalyzerNames, analyzer.GetName())
}

// Analyze executes all analyzers in a group for a given source.
func (g *Group) Analyze(source *scanner.Source) {
	for _, analyzer := range g.Analyzers {
		logrus.Debugf("Running analyzer %s", analyzer.GetName())
		issues, err := analyzer.Execute(source)

		if err != nil {
			logrus.Errorf("Analyzer %s got error: %s", analyzer.GetID(), err)
			continue
		}

		g.Issues = append(g.Issues, issues...)
	}
}

// AnalyzeMany executes all analyzers in a group of many sources.
func (g *Group) AnalyzeMany(sources []*scanner.Source) {
	for _, source := range sources {
		g.Analyze(source)
	}
}

func getUrl(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return []byte(""), err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return []byte(""), fmt.Errorf("Got non-200 HTTP response from %s", url)
	}

	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return []byte(""), err
	}

	return bodyBytes, nil
}
